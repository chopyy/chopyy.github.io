{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to my page\n\n\nTo keep up in mind some thoughts...", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-my-page", 
            "text": "To keep up in mind some thoughts...", 
            "title": "Welcome to my page"
        }, 
        {
            "location": "/quadrocopter/Getting-Started-with-PX4-Toolchain/", 
            "text": "PX4 Toolchain Installation (Windows)\n\n\nThis article is mostly an adaption of the guideline from (https://pixhawk.org/dev/toolchain_installation_win) available on pixhawk website under category \nDeveloper Manual\n.\nFor compiling the source you do need two files:\n\n\n\n\nPX4 Toolchain\n\n\nPX4 Driver\n\n\n\n\nInitial Setup\n\n\nInstall the PX4 Toolchain and the PX4 Driver on your Microsoft Windows OS. To get an initial software setup you then have to execute the following menu command: \nStart -\n PX4 Software download\n.\n\nNote:\n You do not need to adjust the \nPATH\n settings.\n\n\nEclipse\n\n\nThe PX4 Toolchain comes with an Eclipse project you can use for development. It is recommended to start the Eclipse IDE over the specific batch file delivered by the PX4 Toolchain: \nStart -\n PX4 Eclipse\n.\n\n\n\n\nIf you're working on a 64-bit system there may be an issue starting Eclipse, because of the 64-Bit JRE / JDK. In this case you have to download either the JRE or JDK 32-bit from (http://www.oracle.com/technetwork/java/javase/downloads/index.html). \nIf Eclipse starts up it will automatically assume that your PX4 toolchain is located under C:\\px4. The PX4 Eclipse will use C:\\px4\\workspace as its workspace folder.\n\n\nImport the existing Makefile Project\n\n\n\n\nAfter starting Eclipse you have to import the PX4 Firmware Makefile project. Go to \nFile -\n New -\n  Makefile Project with Existing Code\n.\n\n\n\n\n\n\n\n\nClick on \nBrowse\n and choose \nC:\\px4\\Firmware\n as your Existing Code Location.\n\n\nAs \nToolchain for Indexer Settings\n you have to choose the Gnu Cross Compiler \nCROSS GCC\n\n\nFinish\n the \nNew Project\n wizard.\n\n\n\n\n\n\nCreating Make Targets\n\n\nThis step is important so you can build your source code and flash it onto your pixhawk hardware.\n\n\n\n\nIn Eclipse open the window \nMake Target\n.\n\n\nRight click on the project \nFirmware\n and choose \nNew\n.\n\n\n\n\n\n\n\n\n\n\nAdd the following Make Targets repeating step 2 for each target:\n\n\n\n\n\n\nall\n - builds the autopilot software (depends on target \narchives\n)\n\n\n\n\narchives\n - builds the NuttX OS\n\n\nclean\n - cleans the application layer only\n\n\ndistclean\n - cleans the application layer and the NuttX build\n\n\nupload px4fmu-v1_default\n - uploads to PX4FMU v1.x boards\n\n\nupload px4fmu-v2_default\n - uploads to PX4FMU v2.x boards\n\n\n\n\nBuild\n\n\nNote:\n Before you are able to build the source with \nmake all\n you have to build the RTOS NuttX itself by executing \nmake archives\n. This takes up to 20 minutes on a current i7 with 8 GB of RAM until it is finished. Afterwards try to execute \nmake all\n. If Eclipse is configured correctly you will be able to build the complete software and later flash it onto the controller.", 
            "title": "Getting Started PX4"
        }, 
        {
            "location": "/quadrocopter/Getting-Started-with-PX4-Toolchain/#px4-toolchain-installation-windows", 
            "text": "This article is mostly an adaption of the guideline from (https://pixhawk.org/dev/toolchain_installation_win) available on pixhawk website under category  Developer Manual .\nFor compiling the source you do need two files:   PX4 Toolchain  PX4 Driver", 
            "title": "PX4 Toolchain Installation (Windows)"
        }, 
        {
            "location": "/quadrocopter/Getting-Started-with-PX4-Toolchain/#initial-setup", 
            "text": "Install the PX4 Toolchain and the PX4 Driver on your Microsoft Windows OS. To get an initial software setup you then have to execute the following menu command:  Start -  PX4 Software download . Note:  You do not need to adjust the  PATH  settings.", 
            "title": "Initial Setup"
        }, 
        {
            "location": "/quadrocopter/Getting-Started-with-PX4-Toolchain/#eclipse", 
            "text": "The PX4 Toolchain comes with an Eclipse project you can use for development. It is recommended to start the Eclipse IDE over the specific batch file delivered by the PX4 Toolchain:  Start -  PX4 Eclipse .   If you're working on a 64-bit system there may be an issue starting Eclipse, because of the 64-Bit JRE / JDK. In this case you have to download either the JRE or JDK 32-bit from (http://www.oracle.com/technetwork/java/javase/downloads/index.html). \nIf Eclipse starts up it will automatically assume that your PX4 toolchain is located under C:\\px4. The PX4 Eclipse will use C:\\px4\\workspace as its workspace folder.  Import the existing Makefile Project   After starting Eclipse you have to import the PX4 Firmware Makefile project. Go to  File -  New -   Makefile Project with Existing Code .     Click on  Browse  and choose  C:\\px4\\Firmware  as your Existing Code Location.  As  Toolchain for Indexer Settings  you have to choose the Gnu Cross Compiler  CROSS GCC  Finish  the  New Project  wizard.    Creating Make Targets  This step is important so you can build your source code and flash it onto your pixhawk hardware.   In Eclipse open the window  Make Target .  Right click on the project  Firmware  and choose  New .      Add the following Make Targets repeating step 2 for each target:    all  - builds the autopilot software (depends on target  archives )   archives  - builds the NuttX OS  clean  - cleans the application layer only  distclean  - cleans the application layer and the NuttX build  upload px4fmu-v1_default  - uploads to PX4FMU v1.x boards  upload px4fmu-v2_default  - uploads to PX4FMU v2.x boards", 
            "title": "Eclipse"
        }, 
        {
            "location": "/quadrocopter/Getting-Started-with-PX4-Toolchain/#build", 
            "text": "Note:  Before you are able to build the source with  make all  you have to build the RTOS NuttX itself by executing  make archives . This takes up to 20 minutes on a current i7 with 8 GB of RAM until it is finished. Afterwards try to execute  make all . If Eclipse is configured correctly you will be able to build the complete software and later flash it onto the controller.", 
            "title": "Build"
        }, 
        {
            "location": "/ros/Installing-ROS/", 
            "text": "", 
            "title": "Installing ROS indigo"
        }, 
        {
            "location": "/linux/RT-PREEMPT-on-Raspberry-PI/", 
            "text": "Enable real-time capabilities of the mainline kernel on the Raspberry PI\n\n\nEmbedded systems often need hard realtime capabilities for driving actuators or reading out sensor data at a given time. This guideline shows how to apply the realtime kernel from OSADL on a Raspberry PI (RPI) v2. We will go through downloading the sources, cross-compiling the kernel on a PC architecture and finally flashing it on the RPI.\n\n\nI'm cross-compiling the kernel on an Intel i7 with 8 GB of RAM in Ubuntu as my host system, because it will compile a lot faster than compiling the kernel on the RPI itself.\n\n\nDownloading and Patching\n\n\nCheck the kernel version of your RPI:\n\n\nuname -r\n# ...\n\n\n\n\nDownload both the kernel as well as the corresponding RT patch. We will work with \nkernel version 3.18.11\n:\n\n\ncd /usr/src/kernels\nsudo wget https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.18.11.tar.xz\nsudo wget https://www.kernel.org/pub/linux/kernel/projects/rt/3.18/older/patch-3.18.11-rt7.patch.xz\n\n\n\n\nIf directory kernels does not exist create it:\n\n\ncd /usr/src/\nmkdir kernels\n\n\n\n\nUnpack the kernel:\n\n\nsudo tar -xvJf linux-3.18.11.tar.xz\n\n\n\n\nRename the kernel directory:\n\n\nsudo mv linux-3.18.11 linux-3.18.11-rt\n\n\n\n\nChange the directory into the unpacked kernel and patch it with the RT PREEMPT patch.\n\n\nsudo -i\ncd /usr/src/kernels/linux-3.18.11-rt/\nsudo xz -dc /usr/src/kernels/patch-3.18.11-rt7.patch.xz | patch -p1\n\n\n\n\nCross-Compiler\n\n\nThere are more than one ARM cross compilers for Ubuntu Linux. We will use the provided compiler from the \nRaspberry Pi tools section\n on GitHub.\n\n\ncd /opt/\ngit clone git://github.com/raspberrypi/tools.git --depth 1\n\n\n\n\nConfiguration\n\n\nBefore you are able to configure the kernel make sure you installed all necessary dependencies:\n\n\nsudo apt-get install libncurses5-dev\n\n\n\n\nWe also need to copy the kernel \n.config file\n from the RPI into the build directory.\nFirst we back up our default config. Then we will transfer the RPI .config from the embedded device onto the PC.\n\n\nsudo mv .config .config_backup\nsudo rsync -avz -e ssh pi@141.7.25.81:/proc/config.gz /usr/src/kernels/linux-3.18.11-rt/.config\n\n\n\n\nSet an environment variable for the prefix of the cross compiler toolchain:\n\n\nexport CCPREFIX=/opt/rpi-tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin/arm-linux-gnueabihf-\n\n\n\n\nIn the same terminal where you exported the environment variable run your first make command to configure your kernel:\n\n\nsudo make ARCH=arm CROSS_COMPILE=${CCPREFIX} menuconfig\n\n\n\n\nThis make target will start up a graphical interface shown below. \n\n\n\n\nFor PC architectures the realtime settings are under \nProcessor type and features\n. Select the \nPreemption Model\n and choose \nFully Preemptible Kernel (RT)\n like in the screenshot below:\n\n\n\nIf you configured the ARM build correctly the Preemption Model of the PREEMPT patch can be found under \nKernel Features\n and then \nPreemption Model\n like shown in the following image:\n\n\n\n\nAlso choose \nFully Preemptible Kernel (RT)\n.\n\n\nNote:\n If this option is not available the patch was not successful and something went completly wrong. Try to patch the downloaded kernel once again.\n\n\nYou can now compile the kernel on the PC. If you are working on a multi-processor platform enable parallel jobs for a quicker build switching on \n-j #n\n where #n is the number of parallel jobs that will be used. This should be 1.5 times your number of cores. Using this option makes the build about 48% faster on a modern Intel/AMD processor.\n\n\nsudo make ARCH=arm CROSS_COMPILE=${CCPREFIX} -j5\n\n\n\n\nNow you can imagine how long it would take to compile the kernel directly on the RPI itself (more than 3 hrs I guess), by only enabling the parallel jobs.", 
            "title": "Realtime-Preempt Kernel on Raspberry PI"
        }, 
        {
            "location": "/linux/RT-PREEMPT-on-Raspberry-PI/#enable-real-time-capabilities-of-the-mainline-kernel-on-the-raspberry-pi", 
            "text": "Embedded systems often need hard realtime capabilities for driving actuators or reading out sensor data at a given time. This guideline shows how to apply the realtime kernel from OSADL on a Raspberry PI (RPI) v2. We will go through downloading the sources, cross-compiling the kernel on a PC architecture and finally flashing it on the RPI.  I'm cross-compiling the kernel on an Intel i7 with 8 GB of RAM in Ubuntu as my host system, because it will compile a lot faster than compiling the kernel on the RPI itself.", 
            "title": "Enable real-time capabilities of the mainline kernel on the Raspberry PI"
        }, 
        {
            "location": "/linux/RT-PREEMPT-on-Raspberry-PI/#downloading-and-patching", 
            "text": "Check the kernel version of your RPI:  uname -r\n# ...  Download both the kernel as well as the corresponding RT patch. We will work with  kernel version 3.18.11 :  cd /usr/src/kernels\nsudo wget https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.18.11.tar.xz\nsudo wget https://www.kernel.org/pub/linux/kernel/projects/rt/3.18/older/patch-3.18.11-rt7.patch.xz  If directory kernels does not exist create it:  cd /usr/src/\nmkdir kernels  Unpack the kernel:  sudo tar -xvJf linux-3.18.11.tar.xz  Rename the kernel directory:  sudo mv linux-3.18.11 linux-3.18.11-rt  Change the directory into the unpacked kernel and patch it with the RT PREEMPT patch.  sudo -i\ncd /usr/src/kernels/linux-3.18.11-rt/\nsudo xz -dc /usr/src/kernels/patch-3.18.11-rt7.patch.xz | patch -p1  Cross-Compiler  There are more than one ARM cross compilers for Ubuntu Linux. We will use the provided compiler from the  Raspberry Pi tools section  on GitHub.  cd /opt/\ngit clone git://github.com/raspberrypi/tools.git --depth 1  Configuration  Before you are able to configure the kernel make sure you installed all necessary dependencies:  sudo apt-get install libncurses5-dev  We also need to copy the kernel  .config file  from the RPI into the build directory.\nFirst we back up our default config. Then we will transfer the RPI .config from the embedded device onto the PC.  sudo mv .config .config_backup\nsudo rsync -avz -e ssh pi@141.7.25.81:/proc/config.gz /usr/src/kernels/linux-3.18.11-rt/.config  Set an environment variable for the prefix of the cross compiler toolchain:  export CCPREFIX=/opt/rpi-tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin/arm-linux-gnueabihf-  In the same terminal where you exported the environment variable run your first make command to configure your kernel:  sudo make ARCH=arm CROSS_COMPILE=${CCPREFIX} menuconfig  This make target will start up a graphical interface shown below.    For PC architectures the realtime settings are under  Processor type and features . Select the  Preemption Model  and choose  Fully Preemptible Kernel (RT)  like in the screenshot below:  If you configured the ARM build correctly the Preemption Model of the PREEMPT patch can be found under  Kernel Features  and then  Preemption Model  like shown in the following image:   Also choose  Fully Preemptible Kernel (RT) .  Note:  If this option is not available the patch was not successful and something went completly wrong. Try to patch the downloaded kernel once again.  You can now compile the kernel on the PC. If you are working on a multi-processor platform enable parallel jobs for a quicker build switching on  -j #n  where #n is the number of parallel jobs that will be used. This should be 1.5 times your number of cores. Using this option makes the build about 48% faster on a modern Intel/AMD processor.  sudo make ARCH=arm CROSS_COMPILE=${CCPREFIX} -j5  Now you can imagine how long it would take to compile the kernel directly on the RPI itself (more than 3 hrs I guess), by only enabling the parallel jobs.", 
            "title": "Downloading and Patching"
        }
    ]
}