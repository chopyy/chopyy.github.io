{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to my page\n\n\nTo keep up in mind some thoughts...", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-my-page", 
            "text": "To keep up in mind some thoughts...", 
            "title": "Welcome to my page"
        }, 
        {
            "location": "/quadrocopter/Getting-Started-with-PX4-Toolchain/", 
            "text": "PX4 Toolchain Installation (Windows)\n\n\nThis article is mostly an adaption of the guideline from (https://pixhawk.org/dev/toolchain_installation_win) available on pixhawk website under category \nDeveloper Manual\n.\nFor compiling the source you do need two files:\n\n\n\n\nPX4 Toolchain\n\n\nPX4 Driver\n\n\n\n\nInitial Setup\n\n\nInstall the PX4 Toolchain and the PX4 Driver on your Microsoft Windows OS. To get an initial software setup you then have to execute the following menu command: \nStart -\n PX4 Software download\n.\n\nNote:\n You do not need to adjust the \nPATH\n settings.\n\n\nEclipse\n\n\nThe PX4 Toolchain comes with an Eclipse project you can use for development. It is recommended to start the Eclipse IDE over the specific batch file delivered by the PX4 Toolchain: \nStart -\n PX4 Eclipse\n.\n\n\n\n\nIf you're working on a 64-bit system there may be an issue starting Eclipse, because of the 64-Bit JRE / JDK. In this case you have to download either the JRE or JDK 32-bit from (http://www.oracle.com/technetwork/java/javase/downloads/index.html). \nIf Eclipse starts up it will automatically assume that your PX4 toolchain is located under C:\\px4. The PX4 Eclipse will use C:\\px4\\workspace as its workspace folder.\n\n\nImport the existing Makefile Project\n\n\n\n\nAfter starting Eclipse you have to import the PX4 Firmware Makefile project. Go to \nFile -\n New -\n  Makefile Project with Existing Code\n.\n\n\n\n\n\n\n\n\nClick on \nBrowse\n and choose \nC:\\px4\\Firmware\n as your Existing Code Location.\n\n\nAs \nToolchain for Indexer Settings\n you have to choose the Gnu Cross Compiler \nCROSS GCC\n\n\nFinish\n the \nNew Project\n wizard.\n\n\n\n\n\n\nCreating Make Targets\n\n\nThis step is important so you can build your source code and flash it onto your pixhawk hardware.\n\n\n\n\nIn Eclipse open the window \nMake Target\n.\n\n\nRight click on the project \nFirmware\n and choose \nNew\n.\n\n\n\n\n\n\n\n\n\n\nAdd the following Make Targets repeating step 2 for each target:\n\n\n\n\n\n\nall\n - builds the autopilot software (depends on target \narchives\n)\n\n\n\n\narchives\n - builds the NuttX OS\n\n\nclean\n - cleans the application layer only\n\n\ndistclean\n - cleans the application layer and the NuttX build\n\n\nupload px4fmu-v1_default\n - uploads to PX4FMU v1.x boards\n\n\nupload px4fmu-v2_default\n - uploads to PX4FMU v2.x boards\n\n\n\n\nBuild\n\n\nNote:\n Before you are able to build the source with \nmake all\n you have to build the RTOS NuttX itself by executing \nmake archives\n. This takes up to 20 minutes on a current i7 with 8 GB of RAM until it is finished. Afterwards try to execute \nmake all\n. If Eclipse is configured correctly you will be able to build the complete software and later flash it onto the controller.", 
            "title": "Getting Started PX4"
        }, 
        {
            "location": "/quadrocopter/Getting-Started-with-PX4-Toolchain/#px4-toolchain-installation-windows", 
            "text": "This article is mostly an adaption of the guideline from (https://pixhawk.org/dev/toolchain_installation_win) available on pixhawk website under category  Developer Manual .\nFor compiling the source you do need two files:   PX4 Toolchain  PX4 Driver", 
            "title": "PX4 Toolchain Installation (Windows)"
        }, 
        {
            "location": "/quadrocopter/Getting-Started-with-PX4-Toolchain/#initial-setup", 
            "text": "Install the PX4 Toolchain and the PX4 Driver on your Microsoft Windows OS. To get an initial software setup you then have to execute the following menu command:  Start -  PX4 Software download . Note:  You do not need to adjust the  PATH  settings.", 
            "title": "Initial Setup"
        }, 
        {
            "location": "/quadrocopter/Getting-Started-with-PX4-Toolchain/#eclipse", 
            "text": "The PX4 Toolchain comes with an Eclipse project you can use for development. It is recommended to start the Eclipse IDE over the specific batch file delivered by the PX4 Toolchain:  Start -  PX4 Eclipse .   If you're working on a 64-bit system there may be an issue starting Eclipse, because of the 64-Bit JRE / JDK. In this case you have to download either the JRE or JDK 32-bit from (http://www.oracle.com/technetwork/java/javase/downloads/index.html). \nIf Eclipse starts up it will automatically assume that your PX4 toolchain is located under C:\\px4. The PX4 Eclipse will use C:\\px4\\workspace as its workspace folder.  Import the existing Makefile Project   After starting Eclipse you have to import the PX4 Firmware Makefile project. Go to  File -  New -   Makefile Project with Existing Code .     Click on  Browse  and choose  C:\\px4\\Firmware  as your Existing Code Location.  As  Toolchain for Indexer Settings  you have to choose the Gnu Cross Compiler  CROSS GCC  Finish  the  New Project  wizard.    Creating Make Targets  This step is important so you can build your source code and flash it onto your pixhawk hardware.   In Eclipse open the window  Make Target .  Right click on the project  Firmware  and choose  New .      Add the following Make Targets repeating step 2 for each target:    all  - builds the autopilot software (depends on target  archives )   archives  - builds the NuttX OS  clean  - cleans the application layer only  distclean  - cleans the application layer and the NuttX build  upload px4fmu-v1_default  - uploads to PX4FMU v1.x boards  upload px4fmu-v2_default  - uploads to PX4FMU v2.x boards", 
            "title": "Eclipse"
        }, 
        {
            "location": "/quadrocopter/Getting-Started-with-PX4-Toolchain/#build", 
            "text": "Note:  Before you are able to build the source with  make all  you have to build the RTOS NuttX itself by executing  make archives . This takes up to 20 minutes on a current i7 with 8 GB of RAM until it is finished. Afterwards try to execute  make all . If Eclipse is configured correctly you will be able to build the complete software and later flash it onto the controller.", 
            "title": "Build"
        }, 
        {
            "location": "/ros/Installing-ROS/", 
            "text": "", 
            "title": "Installing ROS indigo"
        }, 
        {
            "location": "/linux/RT-PREEMPT-on-Raspberry-PI/", 
            "text": "Enable real-time capabilities of the mainline kernel on the Raspberry PI\n\n\nEmbedded systems often need hard realtime capabilities for driving actuators or reading out sensor data at a given time. This guideline shows how to apply the realtime kernel from OSADL on a Raspberry PI (RPI) v2. We will go through downloading the sources, cross-compiling the kernel on a PC architecture and finally flashing it on the RPI.\n\n\nI'm cross-compiling the kernel on an Intel i7 CPU with 8 GB of RAM in Ubuntu as my host system, because it will compile a lot faster than compiling the kernel on the RPI itself. As embedded device I'm using a Raspberry PI v2 Model B.\n\n\nDownloading and Patching\n\n\nThere are several possible kernels you can use for building a kernel with PREEMPT RT. The easiest way to get a realtime kernel running on the RPI is to use the raspberry kernel from their GitHub repositories. Another way is to use the Vanilla kernel, but you have to add all extras and the Raspberry firmware by yourself. In this guide I will describe the way for patching and building the realtime kernel with the kernel source from the GitHub repository of Raspberry. I will try to release a guide for patching and running a Vanilla kernel with PREEMPT RT patch on the RPI soon.\n\n\nDownload the Raspberry kernel from GitHub:\n\n\ncd /usr/src/\nmkdir kernels\ncd kernels\ngit clone --depth=1 https://github.com/raspberrypi/linux\n\n\n\n\nLook for the version of the kernel. You will find the information within the Makefile and it should look something like:\n\n\nVERSION = 3\nPATCHLEVEL = 18\nSUBLEVEL = 11\n\n\n\n\nSo in my case I will need the realtime patch 3.18.11:\n\n\ncd /usr/src/kernels\nsudo wget https://www.kernel.org/pub/linux/kernel/projects/rt/3.18/older/patch-3.18.11-rt7.patch.xz\n\n\n\n\nIf your kernel version differs from the one described in this guide, search for the appropriate kernel patch on \nhttps://www.kernel.org/pub/linux/kernel/projects/rt/\n and download it like described above.\n\n\nRename the folder you cloned from GitHub, because we will patch it in the next step:\n\n\ncd /usr/src/kernels\nsudo mv linux linux-rt\n\n\n\n\nGo into your \nlinux-rt\n directory and patch it with the downloaded RT PREEMPT patch:\n\n\nsudo -i\ncd /usr/src/kernels/linux-3.18.11-rt/\nsudo xz -dc /usr/src/kernels/patch-3.18.11-rt7.patch.xz | patch -p1\n\n\n\n\nNote:\n This step has to be executed as root explicitly (sudo -i).\n\n\nCross Compiler\n\n\nThere is more than one ARM cross compiler for Ubuntu Linux. We will use the provided compiler from the \nRaspberry Pi tools section\n on GitHub.\n\n\ncd /opt/\ngit clone git://github.com/raspberrypi/tools.git --depth 1\n\n\n\n\nConfiguration\n\n\nNow comes the exciting part: Configuring the kernel! But before you are able to configure the kernel and activate the realtime capabilities, make sure you installed all necessary dependencies and get the linux kernel ready to compile:\n\n\nsudo apt-get install libncurses5-dev\nmake mrproper\n\n\n\n\nSet an environment variable for the prefix of the cross compiler toolchain:\n\n\nexport CCPREFIX=/opt/rpi-tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin/arm-linux-gnueabihf-\n\n\n\n\nMake an initial config for the Raspberry build:\n\n\nsudo make ARCH=arm CROSS_COMPILE=${CCPREFIX} bcm2709_defconfig\n\n\n\n\nIn the same terminal where you exported the environment variable run your first make command to configure your realtime kernel:\n\n\nKERNEL=kernel7\nsudo make ARCH=arm CROSS_COMPILE=${CCPREFIX} menuconfig\n\n\n\n\nThis make target will start up a graphical interface shown below: \n\n\n\n\nIf you configured the ARM build correctly the Preemption Model of the PREEMPT patch can be found under \nKernel Features\n and then \nPreemption Model\n like shown in the following image:\n\n\n\n\nChoose \nFully Preemptible Kernel (RT)\n here.\n\n\nNote:\n If this option is not available the patch was not successful and something went wrong. Try to patch the downloaded kernel once again.\n\n\nCompiling\n\n\nYou can now compile the kernel on the PC. If you are working on a multi-processor platform enable parallel jobs for a quicker build switching on \n-j #n\n where #n is the number of parallel jobs that will be used. This should be 1.5 times your number of cores. Using this option makes the build about 48% faster on a modern Intel/AMD processor. Now you can imagine how long it would take to compile the kernel directly on the RPI itself (more than 3 hrs I guess).\n\n\nFor the raspberry kernel simply execute the following commands:\n\n\ncd /usr/src/kernels/linux-rt\nsudo make ARCH=arm CROSS_COMPILE=${CCPREFIX} zImage modules dtbs -j5\n\n\n\n\nAfter successful compilation the compiled kernel is located under \narch/arm/boot/\n.\n\n\nFlash the compiled kernel\n\n\nAfter compiling the kernel we can flash the image onto the RPI. First, plug in your SD card from RPI and type in the following command for listing all drives:\n\n\nlsblk\n\n\n\n\nYou should see something like this:\n\n\nNAME\nmmcblk0\n|-mmcblk0p1\n|-mmcblk0p2\n\n\n\n\nInstall the modules of the compiled kernel. Make sure you're executing the command from your kernel folder:\n\n\nsudo make ARCH=arm CROSS_COMPILE=${CCPREFIX} INSTALL_MOD_PATH=media/dtuchscherer/13d368bf-6dbf-4751-8ba1-88bed06bef77/ modules_install\nsudo make ARCH=arm CROSS_COMPILE=${CCPREFIX} INSTALL_MOD_PATH=mnt/ext4 modules_install\n\n\n\n\nBack up your old kernel and copy the realtime kernel onto the SD card:\n\n\ncd /usr/src/kernels/linux-rt\nsudo cp /media/dtuchscherer/boot/$KERNEL.img /media/dtuchscherer/boot/$KERNEL-backup.img\nsudo scripts/mkknlimg arch/arm/boot/zImage /media/dtuchscherer/boot/$KERNEL-rt.img\nsudo cp arch/arm/boot/dts/*.dtb /media/dtuchscherer/boot/\nsudo cp arch/arm/boot/dts/overlays/*.dtb* /media/dtuchscherer/boot/overlays/\n\n\n\n\nFinally, adjust the config file:\n\n\nkernel=kernel-rt.img\n\n\n\n\nRunning and Testing\n\n\nAfter you transferred the kernel onto the RPI, plug in your SD card and boot the controller. Test if the kernel and patching of PREEMPT RT was successful with the following command:\n\n\nuname -a\n\n\n\n\nIt should show something similiar to this:\n\n\nLinux raspberrypi 3.18.14-rt7-v7+ #1 SMP PREEMPT RT Fri Jun 12 12:08:45 CEST 2015 armv7l GNU/Linux\n\n\n\n\nThere are tools for testing if the patch was successful. Log in to your RPI over SSH and clone the following GitHub repository:\n\n\nssh pi@141.7.28.126\ngit clone git://git.kernel.org/pub/scm/linux/kernel/git/clrkwllms/rt-tests.git\ncd rt-tests\nmake\n\n\n\n\nReferences\n\n\n\n\nhttp://elinux.org/Raspberry_Pi_Kernel_Compilation\n\n\nhttps://www.raspberrypi.org/documentation/linux/kernel/building.md\n\n\nhttps://www.osadl.org/?id=87", 
            "title": "Realtime-Preempt Kernel on Raspberry PI"
        }, 
        {
            "location": "/linux/RT-PREEMPT-on-Raspberry-PI/#enable-real-time-capabilities-of-the-mainline-kernel-on-the-raspberry-pi", 
            "text": "Embedded systems often need hard realtime capabilities for driving actuators or reading out sensor data at a given time. This guideline shows how to apply the realtime kernel from OSADL on a Raspberry PI (RPI) v2. We will go through downloading the sources, cross-compiling the kernel on a PC architecture and finally flashing it on the RPI.  I'm cross-compiling the kernel on an Intel i7 CPU with 8 GB of RAM in Ubuntu as my host system, because it will compile a lot faster than compiling the kernel on the RPI itself. As embedded device I'm using a Raspberry PI v2 Model B.", 
            "title": "Enable real-time capabilities of the mainline kernel on the Raspberry PI"
        }, 
        {
            "location": "/linux/RT-PREEMPT-on-Raspberry-PI/#downloading-and-patching", 
            "text": "There are several possible kernels you can use for building a kernel with PREEMPT RT. The easiest way to get a realtime kernel running on the RPI is to use the raspberry kernel from their GitHub repositories. Another way is to use the Vanilla kernel, but you have to add all extras and the Raspberry firmware by yourself. In this guide I will describe the way for patching and building the realtime kernel with the kernel source from the GitHub repository of Raspberry. I will try to release a guide for patching and running a Vanilla kernel with PREEMPT RT patch on the RPI soon.  Download the Raspberry kernel from GitHub:  cd /usr/src/\nmkdir kernels\ncd kernels\ngit clone --depth=1 https://github.com/raspberrypi/linux  Look for the version of the kernel. You will find the information within the Makefile and it should look something like:  VERSION = 3\nPATCHLEVEL = 18\nSUBLEVEL = 11  So in my case I will need the realtime patch 3.18.11:  cd /usr/src/kernels\nsudo wget https://www.kernel.org/pub/linux/kernel/projects/rt/3.18/older/patch-3.18.11-rt7.patch.xz  If your kernel version differs from the one described in this guide, search for the appropriate kernel patch on  https://www.kernel.org/pub/linux/kernel/projects/rt/  and download it like described above.  Rename the folder you cloned from GitHub, because we will patch it in the next step:  cd /usr/src/kernels\nsudo mv linux linux-rt  Go into your  linux-rt  directory and patch it with the downloaded RT PREEMPT patch:  sudo -i\ncd /usr/src/kernels/linux-3.18.11-rt/\nsudo xz -dc /usr/src/kernels/patch-3.18.11-rt7.patch.xz | patch -p1  Note:  This step has to be executed as root explicitly (sudo -i).", 
            "title": "Downloading and Patching"
        }, 
        {
            "location": "/linux/RT-PREEMPT-on-Raspberry-PI/#cross-compiler", 
            "text": "There is more than one ARM cross compiler for Ubuntu Linux. We will use the provided compiler from the  Raspberry Pi tools section  on GitHub.  cd /opt/\ngit clone git://github.com/raspberrypi/tools.git --depth 1", 
            "title": "Cross Compiler"
        }, 
        {
            "location": "/linux/RT-PREEMPT-on-Raspberry-PI/#configuration", 
            "text": "Now comes the exciting part: Configuring the kernel! But before you are able to configure the kernel and activate the realtime capabilities, make sure you installed all necessary dependencies and get the linux kernel ready to compile:  sudo apt-get install libncurses5-dev\nmake mrproper  Set an environment variable for the prefix of the cross compiler toolchain:  export CCPREFIX=/opt/rpi-tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin/arm-linux-gnueabihf-  Make an initial config for the Raspberry build:  sudo make ARCH=arm CROSS_COMPILE=${CCPREFIX} bcm2709_defconfig  In the same terminal where you exported the environment variable run your first make command to configure your realtime kernel:  KERNEL=kernel7\nsudo make ARCH=arm CROSS_COMPILE=${CCPREFIX} menuconfig  This make target will start up a graphical interface shown below:    If you configured the ARM build correctly the Preemption Model of the PREEMPT patch can be found under  Kernel Features  and then  Preemption Model  like shown in the following image:   Choose  Fully Preemptible Kernel (RT)  here.  Note:  If this option is not available the patch was not successful and something went wrong. Try to patch the downloaded kernel once again.", 
            "title": "Configuration"
        }, 
        {
            "location": "/linux/RT-PREEMPT-on-Raspberry-PI/#compiling", 
            "text": "You can now compile the kernel on the PC. If you are working on a multi-processor platform enable parallel jobs for a quicker build switching on  -j #n  where #n is the number of parallel jobs that will be used. This should be 1.5 times your number of cores. Using this option makes the build about 48% faster on a modern Intel/AMD processor. Now you can imagine how long it would take to compile the kernel directly on the RPI itself (more than 3 hrs I guess).  For the raspberry kernel simply execute the following commands:  cd /usr/src/kernels/linux-rt\nsudo make ARCH=arm CROSS_COMPILE=${CCPREFIX} zImage modules dtbs -j5  After successful compilation the compiled kernel is located under  arch/arm/boot/ .", 
            "title": "Compiling"
        }, 
        {
            "location": "/linux/RT-PREEMPT-on-Raspberry-PI/#flash-the-compiled-kernel", 
            "text": "After compiling the kernel we can flash the image onto the RPI. First, plug in your SD card from RPI and type in the following command for listing all drives:  lsblk  You should see something like this:  NAME\nmmcblk0\n|-mmcblk0p1\n|-mmcblk0p2  Install the modules of the compiled kernel. Make sure you're executing the command from your kernel folder:  sudo make ARCH=arm CROSS_COMPILE=${CCPREFIX} INSTALL_MOD_PATH=media/dtuchscherer/13d368bf-6dbf-4751-8ba1-88bed06bef77/ modules_install\nsudo make ARCH=arm CROSS_COMPILE=${CCPREFIX} INSTALL_MOD_PATH=mnt/ext4 modules_install  Back up your old kernel and copy the realtime kernel onto the SD card:  cd /usr/src/kernels/linux-rt\nsudo cp /media/dtuchscherer/boot/$KERNEL.img /media/dtuchscherer/boot/$KERNEL-backup.img\nsudo scripts/mkknlimg arch/arm/boot/zImage /media/dtuchscherer/boot/$KERNEL-rt.img\nsudo cp arch/arm/boot/dts/*.dtb /media/dtuchscherer/boot/\nsudo cp arch/arm/boot/dts/overlays/*.dtb* /media/dtuchscherer/boot/overlays/  Finally, adjust the config file:  kernel=kernel-rt.img", 
            "title": "Flash the compiled kernel"
        }, 
        {
            "location": "/linux/RT-PREEMPT-on-Raspberry-PI/#running-and-testing", 
            "text": "After you transferred the kernel onto the RPI, plug in your SD card and boot the controller. Test if the kernel and patching of PREEMPT RT was successful with the following command:  uname -a  It should show something similiar to this:  Linux raspberrypi 3.18.14-rt7-v7+ #1 SMP PREEMPT RT Fri Jun 12 12:08:45 CEST 2015 armv7l GNU/Linux  There are tools for testing if the patch was successful. Log in to your RPI over SSH and clone the following GitHub repository:  ssh pi@141.7.28.126\ngit clone git://git.kernel.org/pub/scm/linux/kernel/git/clrkwllms/rt-tests.git\ncd rt-tests\nmake", 
            "title": "Running and Testing"
        }, 
        {
            "location": "/linux/RT-PREEMPT-on-Raspberry-PI/#references", 
            "text": "http://elinux.org/Raspberry_Pi_Kernel_Compilation  https://www.raspberrypi.org/documentation/linux/kernel/building.md  https://www.osadl.org/?id=87", 
            "title": "References"
        }
    ]
}